
import numpy as np
from PIL import Image, ImageFilter
from scipy import ndimage
from scipy import signal
from math import sin, cos, pi

imageStr = "Untitled.jpg"
im = Image.open(imageStr)
#imageArr = np.array(im)


blurred_image = im.filter(ImageFilter.GaussianBlur(radius=2))
#blurred_image.show()

edge_filter_H = np.array([
 [[-0.05], [0], [0.05]],
 [[-0.05], [0], [0.05]],
 [[-0.05], [0], [0.05]]
])
edge_filter_V = np.array([
 [[-0.05], [-0.05], [-0.05]],
 [[0], [0], [0]],
 [[0.05], [0.05], [0.05]]
])

imgArr = np.array(blurred_image)
#print(imgArr)
print(imgArr.ndim)
horr_img = signal.correlate(imgArr, edge_filter_H).astype(np.uint8)

# convert to pure plack and white
row, col = horr_img.shape[0], horr_img.shape[1]
BWimg = np.zeros(shape=(row, col))

for i, row in enumerate(horr_img):
        for j, pixel in enumerate(row):
            #print(pixel)
            pixelAvg = (int(pixel[0]) + int(pixel[1]) + int(pixel[2]))/3
            #print(pixelAvg)
            if pixelAvg > 127:
                BWimg[i][j] = int(1)
            else:
                BWimg[i][j] = int(0)

#print(horr_img.astype(np.uint8))

## hough space, ie line detection

def build_hough_space_fom_image(img, shape = BWimg.shape, val = 1):
    hough_space = np.zeros(shape)
    for i, row in enumerate(img):
        for j, pixel in enumerate(row):   
            if int(pixel) != val : 
                continue
            hough_space = add_to_hough_space_polar((i,j), hough_space)
    return hough_space
def add_to_hough_space_polar(p, feature_space):
    space = np.linspace(0, pi, len(feature_space))
    d_max = len(feature_space[0]) / 2
    for i in range(len(space)):
        theta = space[i]
        d = int(p[0] * sin(theta) + p[1] * cos(theta)) + d_max # d = x * cos(θ) +y * sin(θ), sometimes used 'p' instead of 'd'
        if (d >= d_max * 2) : continue
        # print(i, int(d))
        feature_space[i, int(d)] += 1
    return feature_space

# Curves generated by collinear points in the image space intersect in peaks (ρ,θ) in the Hough transform space. 
# The more curves intersect at a point, the more “votes” a line in image space will receive. 

ohough_space = build_hough_space_fom_image(BWimg).astype(np.uint8)
# print(ohough_space)
# np.savetxt('test.out', ohough_space, delimiter=',')   # X is an array

# get the equation with the highes votes
print("getting highest votes")
high_votelist = [(0, 0, 0)]*3
# (p, angle, votes)
angle_threshold = 30 # how similar can two angles be?
vote_record = 0

for p, angles in enumerate(ohough_space):
    for angle, votes in enumerate(angles):
        for idx, value in enumerate(high_votelist):
            if abs(angle - value[1]) < angle_threshold:
                if votes > value[2]:
                    high_votelist[idx] = (p, angle, votes)
                break
        else: 
            # executed if the loop ended normally (no break) 
            if votes > vote_record:
                high_votelist.insert(0, (p, angle, votes)) # append to beginning of array
                high_votelist.pop() # pop last element
                vote_record = votes

print("Highest voted is " + str(high_votelist))

##vert_img = signal.correlate(imgArr, edge_filter_V)
imgh = Image.fromarray(ohough_space.astype(np.uint8))
##imgv = Image.fromarray(vert_img.astype(np.uint8))
imgh.show()
##imgv.show()